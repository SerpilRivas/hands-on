# app.py
import os
import time
import json
from pathlib import Path

import pandas as pd
import streamlit as st

from pycaret.classification import load_model as load_cls_model, predict_model

# Import the prescription generator (make sure this file exists)
try:
    from genai_prescriptions import generate_prescription
except ImportError:
    def generate_prescription(provider, input_dict):
        return {
            "recommendation": "Block URL immediately",
            "severity": "High",
            "actions": [
                "Add URL to blacklist",
                "Alert security team",
                "Monitor for similar patterns"
            ]
        }

# -------------------------------------------------
# Page config
# -------------------------------------------------
st.set_page_config(page_title="GenAI-Powered Phishing SOAR", page_icon="üõ°Ô∏è", layout="wide")

# -------------------------------------------------
# Loaders
# -------------------------------------------------
@st.cache_resource
def load_assets():
    """Load the classification model and optional feature importance plot."""
    model_path = "models/phishing_url_detector"
    plot_path = "models/feature_importance.png"
    model = load_cls_model(model_path) if os.path.exists(model_path + ".pkl") else None
    plot = plot_path if os.path.exists(plot_path) else None
    return model, plot


@st.cache_resource
def load_attrib_assets():
    """Load clustering (attribution) model and its metadata."""
    models_dir = Path(__file__).resolve().parent / "models"
    
    try:
        from pycaret.clustering import load_model as load_cluster_model
        cluster_model = load_cluster_model(str(models_dir / "threat_actor_profiler"))
        
        # Load metadata files with fallbacks
        try:
            with open(models_dir / "feature_columns.json", "r") as f:
                feature_columns = json.load(f)
        except FileNotFoundError:
            # Fallback feature columns based on your training data
            feature_columns = [
                "having_IP_Address", "URL_Length", "Shortining_Service", "having_At_Symbol",
                "double_slash_redirecting", "Prefix_Suffix", "having_Sub_Domain", "SSLfinal_State",
                "Abnormal_URL", "URL_of_Anchor", "Links_in_tags", "SFH", "age_of_domain",
                "DNSRecord", "has_political_keyword", "iframe"
            ]
        
        try:
            with open(models_dir / "cluster_to_actor.json", "r") as f:
                cluster_to_actor = json.load(f)
        except FileNotFoundError:
            # Default mapping based on your project requirements
            cluster_to_actor = {
                "0": "Organized Cybercrime",
                "1": "State-Sponsored",
                "2": "Hacktivist"
            }
        
        try:
            with open(models_dir / "actor_descriptions.json", "r") as f:
                actor_descriptions = json.load(f)
        except FileNotFoundError:
            # Default descriptions
            actor_descriptions = {
                "Organized Cybercrime": "High-volume, profit-driven attacks using URL shortening, IP addresses, and abnormal URL structures. Typically targets financial institutions and e-commerce platforms.",
                "State-Sponsored": "Sophisticated, subtle attacks using valid SSL certificates but employing deceptive techniques like prefix/suffix manipulation. Focuses on intelligence gathering and strategic targets.",
                "Hacktivist": "Opportunistic attacks with mixed tactics, often incorporating political keywords and targeting organizations for ideological reasons."
            }

        return cluster_model, feature_columns, cluster_to_actor, actor_descriptions
    
    except Exception as e:
        st.warning(f"Could not load clustering model: {e}")
        return None, [], {}, {}


# Load models and assets
model, feature_plot = load_assets()
cluster_model, feature_columns, cluster_to_actor, actor_descriptions = load_attrib_assets()

if not model:
    st.error("Classification model not found. Run `python train_model.py` first.")
    st.stop()

# -------------------------------------------------
# Sidebar ‚Äì user inputs
# -------------------------------------------------
with st.sidebar:
    st.title("üî¨ URL Feature Input")

    form_values = {
        "url_length": st.select_slider("URL Length", options=["Short", "Normal", "Long"], value="Long"),
        "ssl_state": st.select_slider(
            "SSL Certificate Status", options=["Trusted", "Suspicious", "None"], value="Suspicious"
        ),
        "sub_domain": st.select_slider("Sub-domain Complexity", options=["None", "One", "Many"], value="One"),
        "prefix_suffix": st.checkbox("URL has a Prefix/Suffix (e.g., '-')", value=True),
        "has_ip": st.checkbox("URL uses an IP Address", value=False),
        "short_service": st.checkbox("Is it a shortened URL", value=False),
        "at_symbol": st.checkbox("URL contains '@' symbol", value=False),
        "abnormal_url": st.checkbox("Is it an abnormal URL", value=True),
    }

    st.divider()
    st.markdown("**Additional Content Signals (required by model)**")
    dns_record = st.checkbox("DNS record exists", value=True)
    iframe_tag = st.checkbox("Contains <iframe> tag", value=False)
    political_kw = st.checkbox("Contains political keyword", value=False)
    age_choice = st.select_slider("Age of Domain", options=["New", "Medium", "Old"], value="New")
    age_map = {"New": 0, "Medium": 1, "Old": 2}

    genai_provider = st.selectbox("Select GenAI Provider", ["Gemini", "OpenAI", "Grok"])
    submitted = st.button("üí• Analyze & Initiate Response", use_container_width=True, type="primary")

# -------------------------------------------------
# Main
# -------------------------------------------------
st.title("üõ°Ô∏è GenAI-Powered SOAR for Phishing URL Analysis")

if not submitted:
    st.info("Please provide the URL features in the sidebar and click 'Analyze' to begin.")
    if feature_plot:
        st.subheader("Model Feature Importance")
        st.image(feature_plot, caption="Feature importance from the trained model.")
    st.stop()

# Build the full feature row
input_dict = {
    # Core features
    "having_IP_Address": 1 if form_values["has_ip"] else -1,
    "URL_Length": -1 if form_values["url_length"] == "Short" else (0 if form_values["url_length"] == "Normal" else 1),
    "Shortining_Service": 1 if form_values["short_service"] else -1,
    "having_At_Symbol": 1 if form_values["at_symbol"] else -1,
    "double_slash_redirecting": -1,
    "Prefix_Suffix": 1 if form_values["prefix_suffix"] else -1,
    "having_Sub_Domain": -1 if form_values["sub_domain"] == "None" else (0 if form_values["sub_domain"] == "One" else 1),
    "SSLfinal_State": -1 if form_values["ssl_state"] == "None" else (0 if form_values["ssl_state"] == "Suspicious" else 1),
    "Abnormal_URL": 1 if form_values["abnormal_url"] else -1,
    "URL_of_Anchor": 0,
    "Links_in_tags": 0,
    "SFH": 0,
    # Extra columns some pycaret pipelines expect
    "Subdomain_Level": -1 if form_values["sub_domain"] == "None" else (0 if form_values["sub_domain"] == "One" else 1),
    "age_of_domain": age_map[age_choice],
    "DNSRecord": 1 if dns_record else 0,
    "has_political_keyword": 1 if political_kw else 0,
    "iframe": 1 if iframe_tag else 0,
    "actor_profile": "Unknown",
}
input_data = pd.DataFrame([input_dict])

# Enhanced risk visualization
risk_scores = {
    "Bad SSL": 25 if input_dict["SSLfinal_State"] < 1 else 0,
    "Abnormal URL": 24 if input_dict["Abnormal_URL"] == 1 else 0,
    "Prefix/Suffix": 15 if input_dict["Prefix_Suffix"] == 1 else 0,
    "Shortened URL": 15 if input_dict["Shortining_Service"] == 1 else 0,
    "Complex Sub-domain": 10 if input_dict["having_Sub_Domain"] == 1 else 0,
    "Long URL": 10 if input_dict["URL_Length"] == 1 else 0,
    "Uses IP Address": 8 if input_dict["having_IP_Address"] == 1 else 0,
    "At Symbol": 5 if input_dict["having_At_Symbol"] == 1 else 0,
}
risk_df = pd.DataFrame(list(risk_scores.items()), columns=["Feature", "Risk Contribution"]).sort_values(
    "Risk Contribution", ascending=False
)

# -------------------------------------------------
# Workflow
# -------------------------------------------------
with st.status("Executing SOAR playbook...", expanded=True) as status:
    st.write("‚ñ∂Ô∏è **Step 1: Predictive Analysis** ‚Äî running classification model.")
    time.sleep(0.5)

    # Handle missing columns gracefully
    try:
        prediction = predict_model(model, data=input_data)
    except KeyError as e:
        missing = []
        msg = str(e)
        if "[" in msg and "]" in msg:
            try:
                missing = [c.strip(" '") for c in msg[msg.index("[") + 1 : msg.index("]")].split(",")]
            except Exception:
                missing = []
        for col in missing:
            if col not in input_data.columns:
                input_data[col] = "Unknown" if col == "actor_profile" else 0
        prediction = predict_model(model, data=input_data)

    is_malicious = prediction["prediction_label"].iloc[0] == 1
    verdict = "MALICIOUS" if is_malicious else "BENIGN"
    confidence_score = prediction["prediction_score"].iloc[0]
    
    st.write(f"‚ñ∂Ô∏è **Step 2: Verdict Interpretation** ‚Äî model predicts **{verdict}** (confidence: {confidence_score:.2%}).")
    time.sleep(0.5)

    # Initialize defaults
    actor_name, actor_desc, cluster_id = None, None, None
    prescription = None

    if is_malicious:
        st.write("‚ñ∂Ô∏è **Step 3: Prescriptive Analytics** ‚Äî engaging plan and profiling actor.")
        st.write("‚ñ∂Ô∏è **Step 3a: Threat Actor Attribution** ‚Äî profiling malicious URL...")

        # Threat Attribution Logic
        if cluster_model and feature_columns:
            try:
                # Build exact column order for clustering
                attrib_row = {c: 0 for c in feature_columns}
                for c in feature_columns:
                    if c in input_data.columns:
                        attrib_row[c] = input_data.loc[0, c]
                attrib_input = pd.DataFrame([attrib_row])[feature_columns]

                from pycaret.clustering import predict_model as predict_cluster
                cdf = predict_cluster(cluster_model, data=attrib_input)
                raw = cdf.loc[0, "Cluster"]
                cluster_id = int(raw.replace("Cluster ", "")) if isinstance(raw, str) and raw.startswith("Cluster ") else int(raw)

                # Map cluster to actor (handle both string and int keys)
                mapped = cluster_to_actor.get(str(cluster_id), cluster_to_actor.get(cluster_id))
                actor_name = mapped if mapped else "Unknown Actor"
                actor_desc = actor_descriptions.get(actor_name, "No description available.")

                st.info(f"**Predicted Threat Actor:** {actor_name} (Cluster {cluster_id})")
                st.caption(f"**Profile:** {actor_desc}")
                
            except Exception as e:
                st.warning(f"Could not perform threat attribution: {e}")
                actor_name = "Attribution Failed"
                actor_desc = "Unable to determine threat actor profile due to technical issues."
        else:
            st.warning("Clustering model not available for threat attribution.")

        # Generate prescription
        try:
            prescription = generate_prescription(genai_provider, dict(input_dict))
            status.update(label="‚úÖ SOAR Playbook Executed Successfully!", state="complete", expanded=False)
        except Exception as e:
            st.error(f"Failed to generate prescription: {e}")
            status.update(label="üö® Error during GenAI prescription!", state="error")
    else:
        status.update(label="‚úÖ Analysis Complete. No threat found.", state="complete", expanded=False)

# -------------------------------------------------
# Tabs (Analysis Results)
# -------------------------------------------------
tab1, tab2, tab3, tab4 = st.tabs(
    ["üìä Analysis Summary", "üìà Visual Insights", "üìú Prescriptive Plan", "üïµÔ∏è Threat Attribution"]
)

with tab1:
    st.subheader("Verdict and Key Findings")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if is_malicious:
            st.error("**Prediction: Malicious Phishing URL**", icon="üö®")
        else:
            st.success("**Prediction: Benign URL**", icon="‚úÖ")
    
    with col2:
        confidence_display = confidence_score if is_malicious else (1 - confidence_score)
        st.metric("Model Confidence", f"{confidence_display:.2%}")
    
    # Risk summary
    total_risk = sum(risk_scores.values())
    st.metric("Total Risk Score", f"{total_risk}/112")
    st.caption("This score represents the cumulative risk based on URL features.")

with tab2:
    st.subheader("Visual Analysis")
    
    st.write("#### Risk Contribution by Feature")
    if len(risk_df[risk_df["Risk Contribution"] > 0]) > 0:
        st.bar_chart(risk_df[risk_df["Risk Contribution"] > 0].set_index("Feature"))
        st.caption("Features that contribute to the risk assessment.")
    else:
        st.info("No significant risk factors detected in this URL.")
    
    if feature_plot:
        st.write("#### Model Feature Importance (Global)")
        st.image(feature_plot, caption="Global feature importance from training data.")

with tab3:
    st.subheader("Actionable Response Plan")
    
    if prescription:
        st.success("A prescriptive response plan has been generated by AI.", icon="ü§ñ")
        
        # Display prescription in a more readable format
        if isinstance(prescription, dict):
            for key, value in prescription.items():
                if isinstance(value, list):
                    st.write(f"**{key.title()}:**")
                    for item in value:
                        st.write(f"‚Ä¢ {item}")
                else:
                    st.write(f"**{key.title()}:** {value}")
        else:
            st.json(prescription, expanded=False)
    else:
        st.info("No prescriptive plan was generated because the URL was classified as benign.")

with tab4:
    st.subheader("üïµÔ∏è Threat Attribution Analysis")
    
    if is_malicious:
        if actor_name and actor_name != "Attribution Failed":
            # Main attribution result
            st.success(f"**Identified Threat Actor:** {actor_name}")
            
            # Detailed profile
            st.write("#### Actor Profile")
            st.write(actor_desc or "No detailed description available.")
            
            # Technical details
            if cluster_id is not None:
                st.write("#### Technical Details")
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("Cluster ID", cluster_id)
                with col2:
                    st.metric("Attribution Method", "K-Means Clustering")
            
            # Methodology explanation
            st.write("#### Attribution Methodology")
            st.info(
                "Attribution is inferred using an unsupervised clustering model trained on behavioral patterns "
                "including SSL usage, URL structure anomalies, shortening services, IP address usage, and other "
                "technical indicators. This provides contextual intelligence for security analysts."
            )
            
            # Feature analysis for this actor type
            st.write("#### Key Behavioral Indicators")
            relevant_features = []
            if actor_name == "Organized Cybercrime":
                if input_dict["Shortining_Service"] == 1:
                    relevant_features.append("‚Ä¢ Uses URL shortening services")
                if input_dict["having_IP_Address"] == 1:
                    relevant_features.append("‚Ä¢ Direct IP address usage")
                if input_dict["Abnormal_URL"] == 1:
                    relevant_features.append("‚Ä¢ Abnormal URL structure")
            elif actor_name == "State-Sponsored":
                if input_dict["SSLfinal_State"] == 1:
                    relevant_features.append("‚Ä¢ Valid SSL certificate (sophisticated)")
                if input_dict["Prefix_Suffix"] == 1:
                    relevant_features.append("‚Ä¢ Deceptive prefix/suffix manipulation")
            elif actor_name == "Hacktivist":
                if input_dict["has_political_keyword"] == 1:
                    relevant_features.append("‚Ä¢ Contains political keywords")
                relevant_features.append("‚Ä¢ Mixed attack tactics")
            
            if relevant_features:
                for feature in relevant_features:
                    st.write(feature)
            else:
                st.write("‚Ä¢ Pattern analysis based on multiple behavioral indicators")
                
        else:
            st.warning("‚ö†Ô∏è Threat attribution could not be performed.")
            st.write("This may be due to:")
            st.write("‚Ä¢ Clustering model not available")
            st.write("‚Ä¢ Insufficient feature data")
            st.write("‚Ä¢ Technical issues with the attribution pipeline")
    else:
        st.info("üõ°Ô∏è Attribution is only performed when a URL is classified as malicious.")
        st.write("For benign URLs, no threat actor profiling is necessary.")
